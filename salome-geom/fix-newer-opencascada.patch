diff --git a/src/ARCHIMEDE/Archimede_VolumeSection.cxx b/src/ARCHIMEDE/Archimede_VolumeSection.cxx
index c4a9479a3..79e710e82 100644
--- a/src/ARCHIMEDE/Archimede_VolumeSection.cxx
+++ b/src/ARCHIMEDE/Archimede_VolumeSection.cxx
@@ -90,13 +90,13 @@ void VolumeSection::CenterOfGravity()
       if(Tr.IsNull())
         MESSAGE("Error, null layer" );
       nbNodes = Tr->NbNodes();
-      const TColgp_Array1OfPnt& Nodes = Tr->Nodes();
+      const auto& Nodes = Tr->MapNodeArray();
       
       // Calcul des dimensions de la boite englobante du solide
       
       for(i=1;i<=nbNodes;i++)
         {
-          InitPoint = Nodes(i).Transformed(L.Transformation());
+          InitPoint = (*Nodes)(i).Transformed(L.Transformation());
           if(InitPoint.X() < Xmin)
             Xmin = InitPoint.X();
           if(InitPoint.X() > Xmax)
@@ -145,7 +145,7 @@ Standard_Real VolumeSection::CalculateVolume(Standard_Real Elevation)
       const Poly_Array1OfTriangle& triangles = Tr->Triangles();
       Standard_Integer nbTriangles = Tr->NbTriangles();
       //nbNodes = Tr->NbNodes();
-      const TColgp_Array1OfPnt& Nodes = Tr->Nodes();
+      const auto& Nodes = Tr->MapNodeArray();
       
       // Calcul des volumes de chaque triangle, de chaque face 
       // en tenant compte des triangles coupes par le plan de section
@@ -159,11 +159,11 @@ Standard_Real VolumeSection::CalculateVolume(Standard_Real Elevation)
           else 
             triangles(i).Get(noeud[0], noeud[1], noeud[2]);
           
-          P[0] = Nodes(noeud[0]).Transformed(L.Transformation());
+          P[0] = (*Nodes)(noeud[0]).Transformed(L.Transformation());
           z[0] = P[0].Z();
-          P[1] = Nodes(noeud[1]).Transformed(L.Transformation());
+          P[1] = (*Nodes)(noeud[1]).Transformed(L.Transformation());
           z[1] = P[1].Z();
-          P[2] = Nodes(noeud[2]).Transformed(L.Transformation());
+          P[2] = (*Nodes)(noeud[2]).Transformed(L.Transformation());
           z[2] = P[2].Z();
 
           // Determination des cas aux limites pour les triangles
diff --git a/src/AdvancedEngine/AdvancedEngine_SmoothingSurfaceDriver.cxx b/src/AdvancedEngine/AdvancedEngine_SmoothingSurfaceDriver.cxx
index 42134d10b..ae14b3d6b 100644
--- a/src/AdvancedEngine/AdvancedEngine_SmoothingSurfaceDriver.cxx
+++ b/src/AdvancedEngine/AdvancedEngine_SmoothingSurfaceDriver.cxx
@@ -41,8 +41,6 @@
 #include <TColgp_SequenceOfXYZ.hxx>
 #include <TColStd_Array1OfInteger.hxx>
 
-#include <BRepAdaptor_HSurface.hxx>
-
 #include <BRep_Builder.hxx>
 #include <BRepGProp.hxx>
 #include <BRep_Tool.hxx>
@@ -50,6 +48,7 @@
 #include <BRepPrimAPI_MakeBox.hxx>
 #include <BRepBuilderAPI_MakeFace.hxx>
 #include <BRepAlgoAPI_Cut.hxx>
+#include <BRepAdaptor_Surface.hxx>
 
 #include <GeomPlate_Surface.hxx>
 #include <GeomPlate_BuildPlateSurface.hxx>
@@ -117,9 +116,8 @@ TopoDS_Shape AdvancedEngine_SmoothingSurfaceDriver::MakeSmoothingSurfaceUnClosed
 
   GeomPlate_BuildPlateSurface aBuilder(3,10);
   // ** Initialization of surface
-  Handle(BRepAdaptor_HSurface) HSI = new BRepAdaptor_HSurface();
-  HSI->ChangeSurface().Initialize(aInitShape);
-  aBuilder.LoadInitSurface( BRep_Tool::Surface(HSI->ChangeSurface().Face()));
+  BRepAdaptor_Surface SI(aInitShape);
+  aBuilder.LoadInitSurface( BRep_Tool::Surface(SI.Face()));
 
   Standard_Integer j, j1, j2;
   // cout << "Init surface" << endl;
diff --git a/src/BlockFix/BlockFix_UnionFaces.cxx b/src/BlockFix/BlockFix_UnionFaces.cxx
index 15ed9da9b..15102665d 100644
--- a/src/BlockFix/BlockFix_UnionFaces.cxx
+++ b/src/BlockFix/BlockFix_UnionFaces.cxx
@@ -73,7 +73,6 @@
 
 #include <TColGeom_HArray2OfSurface.hxx>
 
-#include <GeomAdaptor_HSurface.hxx>
 #include <GeomLib_IsPlanarSurface.hxx>
 
 #include <Geom_Surface.hxx>
@@ -85,7 +84,6 @@
 #include <Geom_SurfaceOfLinearExtrusion.hxx>
 #include <Geom_RectangularTrimmedSurface.hxx>
 #include <BRepAdaptor_Surface.hxx>
-#include <BRepAdaptor_HSurface.hxx>
 #include <LocalAnalysis_SurfaceContinuity.hxx>
 #include <GeomConvert_ApproxSurface.hxx>
 #include <Bnd_Box.hxx>
@@ -299,7 +297,7 @@ static Standard_Boolean IsTangentFaces(const TopoDS_Edge& theEdge,
 
 // Computation of the number of samples on the edge.
   BRepAdaptor_Surface              aBAS(theFace);
-  Handle(BRepAdaptor_HSurface)     aBAHS      = new BRepAdaptor_HSurface(aBAS);
+  Handle(Adaptor3d_Surface)        aBAHS(&aBAS);
   Handle(BRepTopAdaptor_TopolTool) aTool      = new BRepTopAdaptor_TopolTool(aBAHS);
   Standard_Integer                 aNbSamples =     aTool->NbSamples();
   const Standard_Integer           aNbSamplesMax =   23;
@@ -888,8 +886,11 @@ Standard_Boolean BlockFix_UnionFaces::IsSameDomain(const TopoDS_Face& aFace,
   if (S1->IsKind(STANDARD_TYPE(Geom_ElementarySurface)) &&
       S2->IsKind(STANDARD_TYPE(Geom_ElementarySurface)))
   {
-    Handle(GeomAdaptor_HSurface) aGA1 = new GeomAdaptor_HSurface(S1);
-    Handle(GeomAdaptor_HSurface) aGA2 = new GeomAdaptor_HSurface(S2);
+    GeomAdaptor_Surface aGA1(S1);
+    GeomAdaptor_Surface aGA2(S2);
+
+    Handle(GeomAdaptor_Surface) aHGA1(&aGA1);
+    Handle(GeomAdaptor_Surface) aHGA2(&aGA1);
 
     Handle(BRepTopAdaptor_TopolTool) aTT1 = new BRepTopAdaptor_TopolTool();
     Handle(BRepTopAdaptor_TopolTool) aTT2 = new BRepTopAdaptor_TopolTool();
@@ -897,7 +898,7 @@ Standard_Boolean BlockFix_UnionFaces::IsSameDomain(const TopoDS_Face& aFace,
     try {
       OCC_CATCH_SIGNALS;
 
-      IntPatch_ImpImpIntersection anIIInt (aGA1, aTT1, aGA2, aTT2, aPrec, aPrec);
+      IntPatch_ImpImpIntersection anIIInt (aHGA1, aTT1, aHGA2, aTT2, aPrec, aPrec);
 
       if (!anIIInt.IsDone() || anIIInt.IsEmpty())
         return false;
diff --git a/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx b/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx
index e7041f483..cba976f93 100644
--- a/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx
+++ b/src/GEOMAlgo/GEOMAlgo_FinderShapeOn2.cxx
@@ -617,7 +617,7 @@ void GEOMAlgo_FinderShapeOn2::InnerPoints(const TopoDS_Face& aF,
   //
   const gp_Trsf& aTrsf=aLoc.Transformation();
   const Poly_Array1OfTriangle& aTrs=aTRF->Triangles();
-  const TColgp_Array1OfPnt& aNodes=aTRF->Nodes();
+  const auto& aNodes=aTRF->MapNodeArray();
   //
   // map link/nbtriangles
   j1=aTrs.Lower();
@@ -655,11 +655,11 @@ void GEOMAlgo_FinderShapeOn2::InnerPoints(const TopoDS_Face& aF,
   }
   //
   // inner nodes=all_nodes - boundary_nodes
-  j1=aNodes.Lower();
-  j2=aNodes.Upper();
+  j1=aNodes->Lower();
+  j2=aNodes->Upper();
   for (j=j1; j<=j2; ++j) {
     if (!aMBN.Contains(j)) {
-      aP=aNodes(j).Transformed(aTrsf);
+      aP=(*aNodes)(j).Transformed(aTrsf);
       aLP.Append(aP);
     }
   }
@@ -769,13 +769,13 @@ void GEOMAlgo_FinderShapeOn2::InnerPoints(const TopoDS_Edge& aE,
   }
   else {
     const gp_Trsf& aTrsf=aLoc.Transformation();
-    const TColgp_Array1OfPnt& aNodes=aTRE->Nodes();
+    const auto& aNodes=aTRE->MapNodeArray();
     //
     aNbNodes=aPTE->NbNodes();
     const TColStd_Array1OfInteger& aInds=aPTE->Nodes();
     for (j=2; j<aNbNodes; ++j) {
       aIndex=aInds(j);
-      aP=aNodes(aIndex).Transformed(aTrsf);
+      aP=(*aNodes)(aIndex).Transformed(aTrsf);
       aLP.Append(aP);
     }
   }
diff --git a/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx b/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx
index a75b8c784..3835354c5 100644
--- a/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx
+++ b/src/GEOMAlgo/GEOMAlgo_ShellSolid.cxx
@@ -114,7 +114,7 @@ void GEOMAlgo_ShellSolidBuilder::PerformInternal(const BOPAlgo_PaveFiller& theFi
   //
   // 3. Fill Images
   // 3.1 Vertice
-  FillImagesVertices();
+  FillImagesVertices(Message_ProgressRange ());
   if (HasErrors()) {
     return;
   }
@@ -124,7 +124,7 @@ void GEOMAlgo_ShellSolidBuilder::PerformInternal(const BOPAlgo_PaveFiller& theFi
     return;
   }
   // 3.2 Edges
-  FillImagesEdges();
+  FillImagesEdges(Message_ProgressRange ());
   if (HasErrors()) {
     return;
   }
@@ -135,7 +135,7 @@ void GEOMAlgo_ShellSolidBuilder::PerformInternal(const BOPAlgo_PaveFiller& theFi
   } 
   //
   // 3.3 Wires
-  FillImagesContainers(TopAbs_WIRE);
+  FillImagesContainers(TopAbs_WIRE, Message_ProgressRange ());
   if (HasErrors()) {
     return;
   }
@@ -146,7 +146,7 @@ void GEOMAlgo_ShellSolidBuilder::PerformInternal(const BOPAlgo_PaveFiller& theFi
   }
   
   // 3.4 Faces
-  FillImagesFaces();
+  FillImagesFaces(Message_ProgressRange ());
   if (HasErrors()) {
     return;
   }
diff --git a/src/GEOMAlgo/GEOMAlgo_Splitter.cxx b/src/GEOMAlgo/GEOMAlgo_Splitter.cxx
index fbd3fbfce..1ba3e71ae 100644
--- a/src/GEOMAlgo/GEOMAlgo_Splitter.cxx
+++ b/src/GEOMAlgo/GEOMAlgo_Splitter.cxx
@@ -282,7 +282,7 @@ void GEOMAlgo_Splitter::PostTreat()
     myShape=aLS.First();
   }
   //
-  BOPAlgo_Builder::PostTreat();
+  BOPAlgo_Builder::PostTreat(Message_ProgressRange ());
 }
 //=======================================================================
 //function : TreatCompound
diff --git a/src/GEOMImpl/GEOMImpl_ICanonicalRecognition.hxx b/src/GEOMImpl/GEOMImpl_ICanonicalRecognition.hxx
index b4d482dcf..4409f199e 100644
--- a/src/GEOMImpl/GEOMImpl_ICanonicalRecognition.hxx
+++ b/src/GEOMImpl/GEOMImpl_ICanonicalRecognition.hxx
@@ -32,6 +32,14 @@
 
 #include <vector>
 
+#include <gp_Sphere.hxx>
+#include <gp_Cone.hxx>
+#include <gp_Cylinder.hxx>
+#include <gp_Circ.hxx>
+#include <gp_Elips.hxx>
+#include <gp_Pln.hxx>
+#include <gp_Lin.hxx>
+
 class GEOM_Object;
 
 class GEOMImpl_ICanonicalRecognition : public GEOM_IOperations {
diff --git a/src/GEOMImpl/GEOMImpl_PipeDriver.cxx b/src/GEOMImpl/GEOMImpl_PipeDriver.cxx
index 48d7d732e..333c0746a 100644
--- a/src/GEOMImpl/GEOMImpl_PipeDriver.cxx
+++ b/src/GEOMImpl/GEOMImpl_PipeDriver.cxx
@@ -85,7 +85,6 @@
 #include <Geom_Conic.hxx>
 #include <Geom_BSplineCurve.hxx>
 #include <Geom_BSplineSurface.hxx>
-#include <GeomAdaptor_HCurve.hxx>
 #include <GeomFill_BSplineCurves.hxx>
 #include <GeomConvert_ApproxCurve.hxx>
 #include <GeomConvert.hxx>
@@ -160,7 +159,7 @@ static GeomFill_Trihedron EvaluateBestSweepMode(const TopoDS_Shape& Spine)
     Standard_Real fpar, lpar;
     Handle(Geom_Curve) aCurve = BRep_Tool::Curve(anEdge, fpar, lpar);
     GeomAdaptor_Curve GAcurve(aCurve, fpar, lpar);
-    Handle(GeomAdaptor_HCurve) GAHcurve = new GeomAdaptor_HCurve(GAcurve);
+    Handle(GeomAdaptor_Curve) GAHcurve(&GAcurve);
 
     Handle(GeomFill_CorrectedFrenet) aCorrFrenet = new GeomFill_CorrectedFrenet(Standard_True); //for evaluation
     aCorrFrenet->SetCurve(GAHcurve);
diff --git a/src/GEOMUtils/GEOMUtils.cxx b/src/GEOMUtils/GEOMUtils.cxx
index 24d7318c0..b18588ca6 100644
--- a/src/GEOMUtils/GEOMUtils.cxx
+++ b/src/GEOMUtils/GEOMUtils.cxx
@@ -96,7 +96,7 @@
 #include <sstream>
 #include <algorithm>
 
-#include <V3d_Coordinate.hxx>
+#include <Standard_Real.hxx>
 
 #include <Standard_Failure.hxx>
 #include <Standard_NullObject.hxx>
@@ -1095,7 +1095,7 @@ gp_Pnt GEOMUtils::ConvertClickToPoint( int x, int y, Handle(V3d_View) aView )
   // inside V3d_View::FitMinMax() method. It's by occt design.
   // So, we should use camera direction instead.
 
-  V3d_Coordinate XAt, YAt, ZAt;
+  Standard_Real XAt, YAt, ZAt;
   aView->At(XAt, YAt, ZAt);
   gp_Pnt AtPoint(XAt, YAt, ZAt);
 
diff --git a/src/GEOMUtils/GEOMUtils_HTrsfCurve2d.cxx b/src/GEOMUtils/GEOMUtils_HTrsfCurve2d.cxx
index 0ca44c88b..a78e4b1c6 100644
--- a/src/GEOMUtils/GEOMUtils_HTrsfCurve2d.cxx
+++ b/src/GEOMUtils/GEOMUtils_HTrsfCurve2d.cxx
@@ -21,7 +21,7 @@
 #include <GEOMUtils_HTrsfCurve2d.hxx>
 
 namespace GEOMUtils {
-  IMPLEMENT_STANDARD_RTTIEXT(HTrsfCurve2d, Adaptor2d_HCurve2d)
+  IMPLEMENT_STANDARD_RTTIEXT(HTrsfCurve2d, Adaptor2d_Curve2d)
 }
 
 //=======================================================================
diff --git a/src/GEOMUtils/GEOMUtils_HTrsfCurve2d.hxx b/src/GEOMUtils/GEOMUtils_HTrsfCurve2d.hxx
index c7d0f01ac..34a675582 100644
--- a/src/GEOMUtils/GEOMUtils_HTrsfCurve2d.hxx
+++ b/src/GEOMUtils/GEOMUtils_HTrsfCurve2d.hxx
@@ -23,7 +23,7 @@
 
 #include <GEOMUtils_TrsfCurve2d.hxx>
 
-#include <Adaptor2d_HCurve2d.hxx>
+#include <Adaptor2d_Curve2d.hxx>
 
 
 namespace GEOMUtils
@@ -31,14 +31,14 @@ namespace GEOMUtils
 
   class HTrsfCurve2d;
 
-  DEFINE_STANDARD_HANDLE(HTrsfCurve2d, Adaptor2d_HCurve2d)
+  DEFINE_STANDARD_HANDLE(HTrsfCurve2d, Adaptor2d_Curve2d)
 
   /*!
    *  This class represents an adaptor curve that represents an original curve
    *  transformed by an anisotropic transformation. This is a class manipulated
    *  by handle.
    */
-  class HTrsfCurve2d : public Adaptor2d_HCurve2d
+  class HTrsfCurve2d : public Adaptor2d_Curve2d
   {
 
   public:
@@ -73,7 +73,7 @@ namespace GEOMUtils
 
   public:
 
-  DEFINE_STANDARD_RTTIEXT(HTrsfCurve2d,Adaptor2d_HCurve2d)
+  DEFINE_STANDARD_RTTIEXT(HTrsfCurve2d,Adaptor2d_Curve2d)
   };
 }
 
diff --git a/src/GEOMUtils/GEOMUtils_TrsfCurve2d.cxx b/src/GEOMUtils/GEOMUtils_TrsfCurve2d.cxx
index 86d47a333..b0e6ccc2d 100644
--- a/src/GEOMUtils/GEOMUtils_TrsfCurve2d.cxx
+++ b/src/GEOMUtils/GEOMUtils_TrsfCurve2d.cxx
@@ -134,7 +134,7 @@ void GEOMUtils::TrsfCurve2d::Intervals(TColStd_Array1OfReal &T,
 //function : Trim
 //purpose  :
 //=======================================================================
-Handle(Adaptor2d_HCurve2d) GEOMUtils::TrsfCurve2d::Trim
+Handle(Adaptor2d_Curve2d) GEOMUtils::TrsfCurve2d::Trim
               (const Standard_Real First, const Standard_Real Last,
                const Standard_Real /*Tol*/) const
 {
diff --git a/src/GEOMUtils/GEOMUtils_TrsfCurve2d.hxx b/src/GEOMUtils/GEOMUtils_TrsfCurve2d.hxx
index 9363f5529..e564c64de 100644
--- a/src/GEOMUtils/GEOMUtils_TrsfCurve2d.hxx
+++ b/src/GEOMUtils/GEOMUtils_TrsfCurve2d.hxx
@@ -109,7 +109,7 @@ namespace GEOMUtils
     /**
      * Redefined method from the base class.
      */
-    Standard_EXPORT Handle(Adaptor2d_HCurve2d) Trim
+    Standard_EXPORT Handle(Adaptor2d_Curve2d) Trim
               (const Standard_Real First, const Standard_Real Last,
                const Standard_Real ) const;
 
diff --git a/src/OCC2VTK/GEOM_EdgeSource.cxx b/src/OCC2VTK/GEOM_EdgeSource.cxx
index 83928b396..cb4969a58 100644
--- a/src/OCC2VTK/GEOM_EdgeSource.cxx
+++ b/src/OCC2VTK/GEOM_EdgeSource.cxx
@@ -138,17 +138,17 @@ void GEOM_EdgeSource::OCC2VTK (const TopoDS_Edge& theEdge,
   } else {
     Standard_Integer aNbNodes = aEdgePoly->NbNodes();
     const TColStd_Array1OfInteger& aNodeIds = aEdgePoly->Nodes();
-    const TColgp_Array1OfPnt& anId2Pnts = T->Nodes();
+    const auto& anId2Pnts = T->MapNodeArray();
 
-    aP1 = anId2Pnts(aNodeIds(1));
-    aP2 = anId2Pnts(aNodeIds(aNbNodes));
+    aP1 = (*anId2Pnts)(aNodeIds(1));
+    aP2 = (*anId2Pnts)(aNodeIds(aNbNodes));
 
     for(int j = 1; j < aNbNodes; j++) {
       Standard_Integer id1 = aNodeIds(j);
       Standard_Integer id2 = aNodeIds(j+1);
       
-      gp_Pnt pt1 = anId2Pnts(id1);
-      gp_Pnt pt2 = anId2Pnts(id2);
+      gp_Pnt pt1 = (*anId2Pnts)(id1);
+      gp_Pnt pt2 = (*anId2Pnts)(id2);
           
       if(!isidtrsf) {
         // apply edge transformation
diff --git a/src/OCC2VTK/GEOM_ShadingFace.cxx b/src/OCC2VTK/GEOM_ShadingFace.cxx
index 7eee99c1e..961675f49 100644
--- a/src/OCC2VTK/GEOM_ShadingFace.cxx
+++ b/src/OCC2VTK/GEOM_ShadingFace.cxx
@@ -85,10 +85,10 @@ OCC2VTK(const TopoDS_Face& theFace,
       
     Standard_Integer i; 
     int aNbOfNodes = thePts->GetNumberOfPoints();
-    const TColgp_Array1OfPnt& Nodes = aPoly->Nodes();
+    const auto& Nodes = aPoly->MapNodeArray();
     Standard_Integer nbNodesInFace = aPoly->NbNodes(); 
     for(i = 1; i <= nbNodesInFace; i++) {
-      gp_Pnt P = Nodes(i);
+      gp_Pnt P = (*Nodes)(i);
       if(!identity) 
         P.Transform(myTransf);
       thePts->InsertNextPoint(P.X(),P.Y(),P.Z());
diff --git a/src/OCC2VTK/GEOM_WireframeFace.cxx b/src/OCC2VTK/GEOM_WireframeFace.cxx
index 07575178c..cacaec1ca 100644
--- a/src/OCC2VTK/GEOM_WireframeFace.cxx
+++ b/src/OCC2VTK/GEOM_WireframeFace.cxx
@@ -30,8 +30,7 @@
 #include <vtkPolyData.h>  
 #include <vtkInformation.h>
 #include <vtkInformationVector.h>
- 
-#include <Adaptor3d_HCurve.hxx>
+
 #include <BRep_Tool.hxx>
 #include <TColStd_Array1OfReal.hxx>
 
diff --git a/src/ShHealOper/ShHealOper_FillHoles.cxx b/src/ShHealOper/ShHealOper_FillHoles.cxx
index d62d95285..1c87d8658 100644
--- a/src/ShHealOper/ShHealOper_FillHoles.cxx
+++ b/src/ShHealOper/ShHealOper_FillHoles.cxx
@@ -31,7 +31,6 @@
 
 #include <BRep_Tool.hxx>
 #include <BRepAdaptor_Curve.hxx>
-#include <BRepAdaptor_HCurve.hxx>
 #include <BRep_Builder.hxx>
 #include <BRepFill_CurveConstraint.hxx>
 #include <BRepBuilderAPI_MakeFace.hxx>
@@ -284,7 +283,7 @@ Handle(Geom_Surface) ShHealOper_FillHoles::buildSurface(const TopoDS_Wire& theWi
 
       TopoDS_Edge ae = TopoDS::Edge(aIter.Value());
       BRepAdaptor_Curve adC(ae);
-      Handle(BRepAdaptor_HCurve) aHAD= new BRepAdaptor_HCurve(adC);
+      Handle(BRepAdaptor_Curve) aHAD(&adC);
       // Handle(BRepFill_CurveConstraint) aConst =
       //     new BRepFill_CurveConstraint (Handle(Adaptor3d_HCurve)::DownCast(aHAD), (Standard_Integer) GeomAbs_C0, myNbPtsOnCur, myTol3d);
       Handle(GeomPlate_CurveConstraint) aConst =
